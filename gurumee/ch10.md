# 예외
===

![대표사진](../intro.png)

> 책 "이펙티브 자바 3판"을 공부하면서 정리한 문서입니다.


## 예외는 진짜 예외 상황에만 사용하라

자바의 예외는 예외 상황에서만 사용한다.

```java
try {
    int i = 0;
    
    while(true) {
        range[i++].climb();
    }
} catch (Exception e) {
    // ...
}
```

이런 코드를 짜면 안된다는 것이다. 절대!! **일상적인 제어 흐름용**으로 쓰면 안된다. `Iterator`처럼 `hasNext` 메서드를 제공하여, 클라이언트가, 오류날 가능성을 적게 API를 설계하라.

다음은 책에서 권고하는, 상태 검사 메서드, 옵셔널, 혹은 특정 값 중 하나를 선택하는 지침이다.

1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면, 옵셔널이나 특정 값을 사용한다.
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면, 옵셔널이나 특정 값을 사용한다.
3. 그 외 모든 경우엔 상태 검사 메서드 방식이 낫다.


## 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

자바에서 문제 상황을 알리는 타입으로는 검사 예외, 런타임 예외, 에러 이렇게 3가지가 있다. 이들을 사용하는 지침은 다음과 같다.

1. 호출하는 쪽에서 복구하리라 여겨지는 상황이라면, 검사 예외를 사용하라
2. 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하라

쉽게 말해서, 복구 가능하다면, 검사 예외 아니라면 런타임 예외를 사용하라는 것이다. 또한, 책에서는 개발자가 구현하는 비검사 `Throwable`은 모두 `RuntimeException` 하위 클래스를 만들 것을 권고 하고 있다. 또한, `Exception`, `RuntimeException`, `Error`를 절대로 상속해서 쓰지 말 것을 당부하고 있다.


## 필요 없는 검사 예외 사용은 피하라

다음 코드 조각들을 보자.

```java
try {
    // ...
} catch (TheCheckedException e) {
    throw new AssertionError();
}
```


```java
try {
    // ...
} catch (TheCheckedException e) {
    e.printStackTrace();
    System.exit(1);
}
```

예외를 다룰 때, 흔히 나올 수 있는 패턴이다. 그러나 한 번쯤 이 코드가 최선인지 생각해 볼 필요가 있다. 이렇게 하면, 해당 코드 블럭의 비용이 꽤 올라가기 때문이다. `try` 블록을 사용해야 하는 것을 물론이고, `Stream API`를 쓸 수 없다. 따라서, 검사 예외가 하나 뿐이라면 피하는 것이 더 좋다. 검사 예외를 회피하는 가장 쉬운 방법은 적절한 결과 타입을 담은 `Optional` 객체를 반환하는 것이다.

또 다른 방법으로, 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 바꾸는 것이다. 항상 적용할 수는 없지만, 조금 더 유연성을 제공한다. 그러나 2 가지 방식 다 단점들이 존재하니 사용할 때 주의해야 한다.


## 표준 예외를 사용하라

"바퀴를 재 발명하지 말자." 예외도 이를 벗어날 수 없다. 표준 예외를 익히면, 개발자에게 이득이 될 것이다. 중요한 것은 `Exception`, `RuntimeException`, `Throwable`, `Error`는 직접 사용하지 말라는 것이다. 책에서 정리한 표준 예외들은 다음과 같다.

| 예외 | 사용처 |
| :-- | :-- |
| IllegalArgumentException | 허용하지 않는 값이 인수로 건네졌을 때 |
| IllegalStateException | 객체가 메서드를 수행하기에 적절하지 않은 상태일 때 |
| NullPointException | null을 허용하지 않는 메서드에 null을 건넸을 때 |
| IndexOutOfBoundsException | 인덱스가 범위를 벗어날 때 |
| ConcurrentModificationException | 허용하지 않는 동시 수정이 발견됐을 때 |
| UnsupportedOperationException | 호출한 메서드를 지원하지 않을 때 |

숫자를 다루는 경우 `ArithmeticException` 혹은 `NumberFormatException` 등을 재사용할 수 있을 것이다. 상황이 부합한다면, 표준 예외를 쓰는 것이 좋다.


## 추상화 수준에 맞는 예외를 던져라

저수준 예외를 처리하지 않고 바깥으로 전파하는 메서드를 만날 경우, **상위 계층에서 저수준 예외를 잡아 자신의 추상화 레벨에 맞는 예외로 바꿔 던져야 한다.** 다음 처럼 말이다.

```java
try {
    // ...
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);
}
```

예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면, `Exception Chaining`을 사용하는 것이 좋다. 다음 코드처럼 말이다.

```java
try {
    // ...
} catch (LowerLevelException cause) {
    throw new HigherLevelException(cause);
}
```

무작정 예외를 전파하는 것보다 좋은 방법이지만, 남용하지는 말자. 다른 방식으로는 상위 계층에서 저수준 예외를 조용히 처리하고 `logging`을 활용하여, 기록해두는 것이 좋다.


## 메서드가 던지는 모든 예외를 문서화하라

메서드가 던지는 예외는 모두 문서화하자. 자바 언어가 요구하진 않지만, 문서화하면 클라이언트에게 매우 이점이 있다. 책에 나온 굵은 글씨만 따로 기록한다.

1. 검사 예외는 항상 따로 따로 선언하고, 각 예외가 발생하는 상황을 자바독의 `@throws` 태그를 사용하여 정확히 문서화한다.
2. 메서드가 던질 수 있는 예외를 각각 `@throws` 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말아라.
3. 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가해도 좋다.


## 예외의 상세 메세지에 실패 관련 정보를 담으라

에러가 재현하기 어려울수록, 예외가 발생할 때, 상세한 정보를 담으면, 디버깅하는 입장에서 매우 좋다. 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 넣어두도록 하자.


## 가능한 한 실패 원자적으로 만들라

일반적으로, 호출된 메서드가 실패하더라도, 해당 객체는 메서드 호출 전 상태를 유지해야 한다. 이러한 특성을 `failure-atomic`이라고 한다. 이 특성을 얻기 위한 방안으로 책에서는 다음의 4가지를 권고하고 있다. 

1. 작업 수행에 앞서, 매개 변수의 유효성을 검사한다.
2. 실패할 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치한다.
3. 임시 복사본에서 작업을 수행한 후, 성공적으로 완료되면 원래 객체와 교환한다.
4. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하여 작업 전 상태로 되돌린다.

첫 번째 방식의 예는 예전 `Stack` 코드의 `pop` 메서드를 찾아 볼 수 있다.

```java
public Object pop() {
    if (size == 0) {
        throw new EmptyStackException();
    }
    // ...
}
```

두 번째 방식의 예는 `TreeMap`이다. `TreeMap`은 원소들을 특정 기준으로 정렬한다. 엉뚱한 원소가 추가되면, 정렬되어 찾는 과정에서, `ClassCastException`을 발생시킨다. 세 번째 방식은 힙 정렬과 유사한다. 특정 컬렉션에 원소를 몰아넣고 그 결과를 다시 원본 객체에 넘겨주는 것이다. 네 번째 방식은 주로 쓰이는 방식은 아니니 이런게 있다 정도만 알고 넘어가자.

동시성을 처리할 때는, 실패 원자성을 확보하기 위한 시도를 할 필요가 없다. 동기화 없이 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있다. 따라서, 에러가 반환되었다 하더라도 그 객체가 사용될 수 있음이 보장되지 않기 때문이다.


## 예외를 무시하지 말라

뭐 이건 너무 원론적인 얘기다. 예외를 만든 것은 그 예외를 처리하기를 바라기 때문이다. 즉 예외에서 에러가 발생할 확률이 적더라도, 예외 처리 코드를 작성하는 것이 좋다. 정 귀찮으면 에러 명을 `ignored`로 바꾸고 밑에 주석에 왜 무시해도 되는지에 대해 문서화하길 바란다.

걍 써라...
