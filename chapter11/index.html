<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>chapter 11 | Effective Java Study</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/effective-java-study/assets/css/0.styles.612e3498.css" as="style"><link rel="preload" href="/effective-java-study/assets/js/app.34abd0d4.js" as="script"><link rel="preload" href="/effective-java-study/assets/js/2.28ccdcca.js" as="script"><link rel="preload" href="/effective-java-study/assets/js/13.f5726a00.js" as="script"><link rel="prefetch" href="/effective-java-study/assets/js/10.1e0a4467.js"><link rel="prefetch" href="/effective-java-study/assets/js/11.d58abc29.js"><link rel="prefetch" href="/effective-java-study/assets/js/12.7f3dee67.js"><link rel="prefetch" href="/effective-java-study/assets/js/14.bdf148c5.js"><link rel="prefetch" href="/effective-java-study/assets/js/3.804d668d.js"><link rel="prefetch" href="/effective-java-study/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/effective-java-study/assets/js/5.40f81d9d.js"><link rel="prefetch" href="/effective-java-study/assets/js/6.a084c838.js"><link rel="prefetch" href="/effective-java-study/assets/js/7.3c66e73f.js"><link rel="prefetch" href="/effective-java-study/assets/js/8.443cd7ba.js"><link rel="prefetch" href="/effective-java-study/assets/js/9.f3d8b2ea.js">
    <link rel="stylesheet" href="/effective-java-study/assets/css/0.styles.612e3498.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/effective-java-study/" class="home-link router-link-active"><!----> <span class="site-name">Effective Java Study</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/effective-java-study/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/effective-java-study/sample.html" class="nav-link">
  Sample
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/effective-java-study/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/effective-java-study/sample.html" class="nav-link">
  Sample
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>chapter 11</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/effective-java-study/chapter11/#chapter-11" class="sidebar-link">chapter 11</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/effective-java-study/chapter11/#동시성" class="sidebar-link">동시성</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_78-공유-중인-가변-데이터는-동기화해-사용하라" class="sidebar-link">78. 공유 중인 가변 데이터는 동기화해 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_79-과도한-동기화는-피하라" class="sidebar-link">79. 과도한 동기화는 피하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_80-스레드보다는-실행자-태스크-스트림을-애용하라" class="sidebar-link">80. 스레드보다는 실행자, 태스크, 스트림을 애용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_81-wait-notify보다는-동시성-유틸리티를-애용하라" class="sidebar-link">81. wait, notify보다는 동시성 유틸리티를 애용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_82-스레드-안전성-수준을-문서화하라" class="sidebar-link">82. 스레드 안전성 수준을 문서화하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_83-지연-초기화는-신중히-사용하라" class="sidebar-link">83. 지연 초기화는 신중히 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter11/#_84-프로그램의-동작을-스레드-스케줄러에-기대지-말라" class="sidebar-link">84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="chapter-11"><a href="#chapter-11" class="header-anchor">#</a> chapter 11</h2> <h2 id="동시성"><a href="#동시성" class="header-anchor">#</a> 동시성</h2> <h3 id="_78-공유-중인-가변-데이터는-동기화해-사용하라"><a href="#_78-공유-중인-가변-데이터는-동기화해-사용하라" class="header-anchor">#</a> 78. 공유 중인 가변 데이터는 동기화해 사용하라</h3> <ul><li>synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장함
<ul><li>한 객체가 일관된 상태를 가지고 생성, 객체에 접근하는 메서드는 lock을 걸고, 객체의 상태를 (필요하다면) 변화시킴</li> <li>제대로 사용한다면 어떤 메서드는 이 객체의 상태가 일관되지 않은 순간을 볼 수 없음</li></ul></li> <li>또한, 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있음 
<ul><li>동기화는 스레드 사이의 안정적인 통신에 꼭 필요하다.</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code>pubic <span class="token keyword">class</span> stopThread <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> stopRequested<span class="token punctuation">;</span>

  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">requestStop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> stopRequested <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 쓰기 메소드</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">boolean</span> <span class="token function">stopRequested</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> stopRequested<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 읽기 메소드</span>

<span class="token punctuation">}</span>
</code></pre></div><ul><li><p>쓰기 메소드와 읽기 메소드 모두가 동기화되지 않으면 동작이 보장되지 않는다.</p></li> <li><p>속도가 더 빠른 대안 : volatile 한정자 (단 주의해서 사용해야 한다.)</p></li> <li><p>배타적 수행과는 상관없지만 항상 가장 최근에 기록된 값을 읽게 됨을 보장함</p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code>pubic <span class="token keyword">class</span> stopThread <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> stopRequested<span class="token punctuation">;</span>
</code></pre></div><ul><li>가변 데이터는 단일 스레드에서만 사용하도록 하고, 스레드 사이에 공유할 데이터로는 불변 데이터만 공유하거나 아무것도 공유하지 말자.</li></ul> <h3 id="_79-과도한-동기화는-피하라"><a href="#_79-과도한-동기화는-피하라" class="header-anchor">#</a> 79. 과도한 동기화는 피하라</h3> <ul><li><p>과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 심지어 예측할 수 없는 동작을 낳기도 함</p></li> <li><p>응답 불가와 안전 실패를 피하려면 동기화 메서드와 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 됨</p></li> <li><p>기본 규칙 : 동기화 영역에서는 가능한 일을 적게 하기</p> <ul><li>외계인 메서드는 동기화 블록 밖에서 호출하기</li> <li>동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아니라 경쟁하느라 낭비하는 시간임</li></ul></li> <li><p>가변 클래스를 작성하려면</p></li></ul> <ol><li>동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하도록 (java.util)</li> <li>동기화를 내부에서 수행해서 스레드 안전한 클래스로 만들기 (java.util.concurrent)</li></ol> <ul><li>StringBuilder는 동기화하지 않은 StringBuffer이다 (!)</li> <li>스레드 안전한 java.util.Random은 동기화하지 않는 버전인 java.util.concurrent.ThreadLocalRandom으로 대체됨 (!!)</li></ul> <h3 id="_80-스레드보다는-실행자-태스크-스트림을-애용하라"><a href="#_80-스레드보다는-실행자-태스크-스트림을-애용하라" class="header-anchor">#</a> 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라</h3> <ul><li>실행자(Executor) 프레임워크 : 인터페이스 기반의 유연한 태스크 실행 기능 (java.utl.concurrent)</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 작업 큐 한 줄로 생성</span>
<span class="token class-name">ExecutorService</span> exec <span class="token operator">=</span> <span class="token class-name">Executros</span><span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 이 실행자에 실행할 task 넘기기</span>
exec<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 실행자를 우아하게 종료시키기</span>
exec<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>Executor 서비스의 주요 기능들</li></ul> <ol><li>특정 태스크가 완료되기를 기다리기 (코드 79-2. get 메서드)</li> <li>태스크 모음 중 하나(invokeAny) 혹은 모든 태스크(invokeAll)가 완료되기를 기다림</li> <li>실행자 서비스가 종료하기를 기다림 (awaitTermination)</li> <li>완료된 태스크들의 결과를 차례로 받음 (ExecutorCompletionService)</li> <li>태스크를 특정 시간에 혹은 주기적으로 실행 (ScheduledThreadPoolExecutor)</li></ol> <ul><li><p>큐를 2개 이상의 쓰레드가 처리하게 하고 싶다면 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(thread pool)을 생성하면 됨</p> <ul><li>필요한 Executor 대부분은 java.util.concurrent.Executor의 정적 팩터리들을 이용해 생성 가능</li></ul></li> <li><p>작은 프로그램, 가벼운 서버라면 Executors.newCachedThreadPool</p></li> <li><p>무거운 프로덕션 서버라면 스레드 개수를 고정한 Executors.newFixedThreadPool, 또는 완전히 통제할 수 있는 ThreadPoolExecutor</p></li> <li><p>작업 큐를 손수 만들거나 스레드를 직접 다루는 것은 일반적으로 삼가야 함</p> <ul><li>스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 됨</li> <li>Executor 프레임워크에서는 작업 단위(task)와 실행 메커니즘이 분리됨
<ul><li>task에는 Runnable, Callable 이 있음
<ul><li>Callable은 Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있음</li></ul></li> <li>java 7~ : Fork-join task를 지원하도록 확장됨</li></ul></li></ul></li> <li><p>자바 병렬 프로그래밍 책 참고.</p></li></ul> <h3 id="_81-wait-notify보다는-동시성-유틸리티를-애용하라"><a href="#_81-wait-notify보다는-동시성-유틸리티를-애용하라" class="header-anchor">#</a> 81. wait, notify보다는 동시성 유틸리티를 애용하라</h3> <ul><li><p>wait, notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.</p></li> <li><p>java.util.concurrent의 고수준 유틸리티 : 실행자 프레임워크, 동시성 컬렉션, 동기화 장치</p> <ul><li>동시성 컬렉션 : List, Queue, Map과 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션
<ul><li>외부에서 락을 추가로 사용하면 오히려 속도가 느려짐</li> <li>Collections.synchronizedMap보다는 ConcurrentHashMap을 사용하는 것이 훨씬 좋음</li> <li>컬렉션 인터페이스 중 일부는 작업이 성공적으로 완료될 때까지 기다리도록 확장됨
<ul><li>ex. BlockingQueue.take - 큐의 첫 원소를 꺼냄
<ul><li>이 때 큐가 비었다면 새로운 원소가 추가될 때까지 기다림 (작업 큐로 사용하기에 적합)</li> <li>ThreadPoolExecutor를 포함한 대부분의 ExecutorService 구현체에서 이 BlockingQueue를 사용</li></ul></li></ul></li></ul></li> <li>동기화 장치 : 스레드가 다른 스레드를 기다릴 수 있게 하여 서로 작업을 조율할 수 있게 해 줌
<ul><li>ex. (사용 빈도) CountDownLatch, Semaphore &gt;&gt; CyclicBarrier, Exchanger / Phaser</li></ul></li></ul></li> <li><p>시간 간격을 잴 때는 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자. (!)</p> <ul><li>더 정확하고 정밀하며 시스템의 실시간 시계의 시간 보정에 영향받지 않음</li></ul></li> <li><p>새로 짜는 코드라면 언제나 wait, notify가 아닌 동시성 유틸리티를 사용할 것</p> <ul><li>하지만 레거시 코드를 읽기 위해서는 내용을 알아야겠죠?</li></ul></li> <li><p>wait : 스레드가 어떤 조건이 충족되기를 기다리게 할 때 사용</p> <ul><li>wait은 반드시 대기 반복문 관용구를 사용하며, 반복문 밖에서는 절대로 호출하지 말자!</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// wait을 사용하는 표준 방식</span>
<span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>조건이 충족되지 않았음<span class="token operator">&gt;</span><span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 락을 놓고, 깨어나면 다시 잡는다</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 조건이 충족됐을 때의 동작</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>notify : 스레드를 하나만 깨움
<ul><li>notifyAll : 모든 스레드를 깨움 (일반적으로 이것을 사용)</li></ul></li></ul> <h3 id="_82-스레드-안전성-수준을-문서화하라"><a href="#_82-스레드-안전성-수준을-문서화하라" class="header-anchor">#</a> 82. 스레드 안전성 수준을 문서화하라</h3> <ul><li><p>사용하는 쪽에서 어떻게 사용될지 모르므로 명확히 문서화해야 한다.</p></li> <li><p>스레드 안전성 수준에 따른 나열</p></li></ul> <ol><li>불변 (immutable)</li> <li>무조건적 스레드 안전 (unconditionally thread-safe)</li> <li>조건부 스레드 안전 (conditionally thread-safe)</li> <li>스레드 안전하지 않음 (non thread-safe)</li> <li>스레드 적대적 (thread-hostile)</li></ol> <h3 id="_83-지연-초기화는-신중히-사용하라"><a href="#_83-지연-초기화는-신중히-사용하라" class="header-anchor">#</a> 83. 지연 초기화는 신중히 사용하라</h3> <ul><li><p>양날의 검</p> <ul><li>클래스 혹은 인스턴스 생성 시의 초기화 비용은 줄지만 그 대신 지연 초기화하는 필드에 접근하는 비용은 커짐</li> <li>해당 필드를 사용하는 인스턴스의 비율이 낮은 반면, 그 필드를 초기화하는 비용이 크다면 제 역할</li> <li>대부분의 상황에서 일반적인 초기화가 지연 초기화보다 나음</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 정적 필드용 지연 초기화 홀더 클래스 관용구</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FieldHolder</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">FieldType</span> field <span class="token operator">=</span> <span class="token function">computeFieldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">FieldType</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token class-name">FieldHolder</span><span class="token punctuation">.</span>field<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// 인스턴스 필드 지연 초기화용 이중검사 관용구</span>
<span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">FieldType</span> field<span class="token punctuation">;</span>

<span class="token keyword">private</span> <span class="token class-name">FieldType</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">FieldType</span> result <span class="token operator">=</span> field<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 첫 번째 검사 (락 사용 X)</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>field <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 두 번째 검사 (락 사용)</span>
      field <span class="token operator">=</span> <span class="token function">computedFieldValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> field<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_84-프로그램의-동작을-스레드-스케줄러에-기대지-말라"><a href="#_84-프로그램의-동작을-스레드-스케줄러에-기대지-말라" class="header-anchor">#</a> 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라</h3> <ul><li>OS마다 구체적인 스케쥴링 정책이 다를 수 있음
<ul><li>정확성이나 성능이 스레드 스케쥴러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어려움</li></ul></li> <li>가장 좋은 방법 : 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것</li> <li>스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안 된다
<ul><li>스레드 풀 크기를 적절히 설정하고, 작업은 짧게 유지</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/effective-java-study/assets/js/app.34abd0d4.js" defer></script><script src="/effective-java-study/assets/js/2.28ccdcca.js" defer></script><script src="/effective-java-study/assets/js/13.f5726a00.js" defer></script>
  </body>
</html>
