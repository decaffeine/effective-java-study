<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>chapter 07 | Effective Java Study</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/effective-java-study/assets/css/0.styles.612e3498.css" as="style"><link rel="preload" href="/effective-java-study/assets/js/app.34abd0d4.js" as="script"><link rel="preload" href="/effective-java-study/assets/js/2.28ccdcca.js" as="script"><link rel="preload" href="/effective-java-study/assets/js/11.d58abc29.js" as="script"><link rel="prefetch" href="/effective-java-study/assets/js/10.1e0a4467.js"><link rel="prefetch" href="/effective-java-study/assets/js/12.7f3dee67.js"><link rel="prefetch" href="/effective-java-study/assets/js/13.f5726a00.js"><link rel="prefetch" href="/effective-java-study/assets/js/14.bdf148c5.js"><link rel="prefetch" href="/effective-java-study/assets/js/3.804d668d.js"><link rel="prefetch" href="/effective-java-study/assets/js/4.7d5f245c.js"><link rel="prefetch" href="/effective-java-study/assets/js/5.40f81d9d.js"><link rel="prefetch" href="/effective-java-study/assets/js/6.a084c838.js"><link rel="prefetch" href="/effective-java-study/assets/js/7.3c66e73f.js"><link rel="prefetch" href="/effective-java-study/assets/js/8.443cd7ba.js"><link rel="prefetch" href="/effective-java-study/assets/js/9.f3d8b2ea.js">
    <link rel="stylesheet" href="/effective-java-study/assets/css/0.styles.612e3498.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/effective-java-study/" class="home-link router-link-active"><!----> <span class="site-name">Effective Java Study</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/effective-java-study/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/effective-java-study/sample.html" class="nav-link">
  Sample
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/effective-java-study/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/effective-java-study/sample.html" class="nav-link">
  Sample
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>chapter 07</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/effective-java-study/chapter07/#chapter-07" class="sidebar-link">chapter 07</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/effective-java-study/chapter07/#람다와-스트림" class="sidebar-link">람다와 스트림</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_42-익명-클래스보다는-람다를-사용하라" class="sidebar-link">42. 익명 클래스보다는 람다를 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_43-람다보다는-메서드-참조를-사용하라" class="sidebar-link">43. 람다보다는 메서드 참조를 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_44-표준-함수형-인터페이스를-사용하라" class="sidebar-link">44. 표준 함수형 인터페이스를 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_45-스트림은-주의해서-사용하라" class="sidebar-link">45. 스트림은 주의해서 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_46-스트림에서는-부작용-없는-함수를-사용하라" class="sidebar-link">46. 스트림에서는 부작용 없는 함수를 사용하라</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_47-반환-타입으로는-스트림보다-컬렉션이-낫다" class="sidebar-link">47. 반환 타입으로는 스트림보다 컬렉션이 낫다</a></li><li class="sidebar-sub-header"><a href="/effective-java-study/chapter07/#_48-스트림-병렬화는-주의해서-적용하라" class="sidebar-link">48. 스트림 병렬화는 주의해서 적용하라</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="chapter-07"><a href="#chapter-07" class="header-anchor">#</a> chapter 07</h2> <h2 id="람다와-스트림"><a href="#람다와-스트림" class="header-anchor">#</a> 람다와 스트림</h2> <h3 id="_42-익명-클래스보다는-람다를-사용하라"><a href="#_42-익명-클래스보다는-람다를-사용하라" class="header-anchor">#</a> 42. 익명 클래스보다는 람다를 사용하라</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 익명 클래스 사용</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  

<span class="token comment">//익명 클래스 대체</span>
<span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><p>타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략</p> <ul><li>컴파일러가 &quot;타입을 알 수 없다&quot; 오류를 반환할 때만 해당 타입을 명시하면 된다</li></ul></li> <li><p>컴파일러가 타입 추론에 필요한 정보 대부분은 제네릭에서 얻으므로 제네릭을 제대로 쓴다</p> <ul><li><code>List words</code>가 아니라, <code>List&lt;String&gt; words</code></li></ul></li> <li><p>그렇다고 람다가 만병통치약은 아니다</p> <ul><li>이름이 없고, 문서화도 못 함</li> <li>코드 자체로 명확히 설명되지 않거나, 코드가 세 줄 이상으로 많아지면 람다를 쓰지 말아야 한다</li></ul></li> <li><p>람다 직렬화하는 일은 극히 삼가야 한다.</p> <ul><li>직렬화 형태가 구현별로(가령 가상머신별로) 다르기 때문???</li></ul></li></ul> <h3 id="_43-람다보다는-메서드-참조를-사용하라"><a href="#_43-람다보다는-메서드-참조를-사용하라" class="header-anchor">#</a> 43. 람다보다는 메서드 참조를 사용하라</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 람다</span>
map<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>count<span class="token punctuation">,</span> incr<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> count <span class="token operator">+</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 메서드 참조</span>
map<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">sum</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><ul><li><p>람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다.</p></li> <li><p>람다가 메서드 참조보다 간결할 때도 있다 : 주로 메서드와 람다가 같은 클래스 안에 있을 때</p> <ul><li>Function.identity() 보다 (x -&gt; x) 가 더 명확하고 눈에 잘 들어옴</li></ul></li> <li><p>메서드 참조의 유형 (같은 기능을 하는 람다)</p> <ol><li>정적</li></ol> <ul><li>Integer::parseInt / str -&gt; Integer.parseInt(str);</li></ul> <ol start="2"><li>한정적 (인스턴스)</li></ol> <ul><li>Instant.now()::isAfter / Instant then = Instant now(); t -&gt; then.isAfter(t)</li></ul> <ol start="3"><li>비한정적 (인스턴스)</li></ol> <ul><li>String::toLowerCase / str -&gt; str.toLowerCase()</li></ul> <ol start="4"><li>클래스 생성자</li></ol> <ul><li>TreeMap&lt;K,V&gt;::new / () -&gt; new TreeMap&lt;K,V&gt;();</li></ul> <ol start="5"><li>배열 생성자</li></ol> <ul><li>int[]::new / len -&gt; new int[len];</li></ul></li> <li><p>람다로는 불가능하나 메서드 참조로는 가능한 유일한 예 : 제네릭 함수 타입 구현</p></li></ul> <h3 id="_44-표준-함수형-인터페이스를-사용하라"><a href="#_44-표준-함수형-인터페이스를-사용하라" class="header-anchor">#</a> 44. 표준 함수형 인터페이스를 사용하라</h3> <ul><li>java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 담겨 있다.
<ul><li>필요한 용도에 맞는 것이 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용</li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>  |      인터페이스       |        함수 시그니처    |          예           |
  |--------------------|----------------------|----------------------|
  | UnaryOperator&lt;T&gt;   | T apply(T t)         | String::toLowerCase  |
  | BinaryOperator&lt;T&gt;  | T apply(T t1, T t2)  | BigInteger::add      |
  | Predicate&lt;T&gt;       | boolean test(T t)    | Collection::isEmpty  |
  | Function&lt;T,R&gt;      | R apply(T t)         | Arrays::asList       |
  | Supplier&lt;T&gt;        | T get()              | Instant::now         |
  | Consumer&lt;T&gt;        | void accept(T t)     | System.out::println  |
</code></pre></div><ul><li><p>UnaryOperator, BinaryOperator : 반환값과 인수의 타입이 같은 함수</p></li> <li><p>Predicate : 인수 하나를 받아 boolean 반환</p></li> <li><p>Function : 인수와 반환 타입이 다름</p></li> <li><p>Supplier : 인수를 받지 않고 값을 반환(제공)</p></li> <li><p>Consumer : 인수를 하나 받고 반환값은 없음(인수를 소비)</p></li> <li><p>표준 함수형 인터페이스 대부분은 기본 타입만 지원함</p> <ul><li>기본 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말 것 (성능!!)</li></ul></li> <li><p><code>@FunctionalInterface</code>어노테이션</p> <ul><li>프로그래머의 의도 명시
<ol><li>해당 인터페이스는 람다용으로 설계됨</li> <li>해당 인터페이스는 추상 메서드를 오직 하나만 가질 수 있음</li> <li>그 결과 유지보수 과정에서 누군가 메서드를 추가하지 못하도록 막음</li></ol></li></ul></li></ul> <h3 id="_45-스트림은-주의해서-사용하라"><a href="#_45-스트림은-주의해서-사용하라" class="header-anchor">#</a> 45. 스트림은 주의해서 사용하라</h3> <ul><li><p>스트림 파이프라인 : 지연 평가 (lazy evaluation)</p> <ul><li>종단 연산(terminal operation)이 수행될 때 evaluation이 이루어진다.</li> <li>종단 연산이 없는 스트림은 아무 일도 하지 않는 명령어와 같다.</li></ul></li> <li><p>메서드 연쇄를 지원하는 fluent API</p></li> <li><p>기본적으로 순차적으로 수행되며, 병렬로 수행하려면 파이프라인 스트림 중 하나에서 parallel() 을 호출하면 되지만 효과를 볼 수 있는 상황이 많지는 않다</p></li> <li><p>스트림으로 처리하기 어려운 일</p> <ul><li>한 데이터가 여러 단계(stage)를 통과할 때 각 단계에서의 값들에 동시에 접근하기는 어려운 구조</li> <li>한 값을 다른 값에 매핑하고 나면 원래의 값은 잃는 구조이므로</li></ul></li> <li><p>스트림을 사용해야 더 깔끔해지는 상황도 있고, 반복이 더 알맞은 경우도 있다.</p> <ul><li>상황에 맞게 사용하자</li> <li>헷갈리면 둘 다 해보자</li></ul></li></ul> <h3 id="_46-스트림에서는-부작용-없는-함수를-사용하라"><a href="#_46-스트림에서는-부작용-없는-함수를-사용하라" class="header-anchor">#</a> 46. 스트림에서는 부작용 없는 함수를 사용하라</h3> <ul><li><p>스트림 패러다임의 핵심 : 계산을 일련의 변환(transformation)으로 재구성하는 부</p></li> <li><p>각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는, 오직 입력만이 결과에 영향을 주는 순수 함수여야 함</p> <ul><li>side-effect가 없어야 한다. 즉 다른 가변 상태를 참조하거나 함수 스스로 다른 상태를 변경하면 안 된다.</li></ul></li> <li><p>forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고, 계산할 때는 쓰지 말자 (헐)</p></li> <li><p>Collector : 스트림을 사용하려면 꼭 배워야 하는 새로운 개념</p> <ul><li>java.util.stream.Collectors
<ul><li>API 문서 참조!</li></ul></li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> topTen <span class="token operator">=</span> freq<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span>freq<span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>마지막 toList()는 Collectors.toList() 인데 정적 임포트하여 사용한 것 (스트림 가독성을 높이기 위해)</p> <ul><li>toMap, maxsBy, groupingBy, partitionBy 등등...</li></ul> <h3 id="_47-반환-타입으로는-스트림보다-컬렉션이-낫다"><a href="#_47-반환-타입으로는-스트림보다-컬렉션이-낫다" class="header-anchor">#</a> 47. 반환 타입으로는 스트림보다 컬렉션이 낫다</h3> <ul><li><p>Stream 인터페이스는 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함할 뿐만 아니라 Iterable이 정의한 방식대로 동작하지만..</p> <ul><li>extends Iterable 하지 않아서 for-each로 스트림을 반복할 수가 없다.</li></ul></li> <li><p>Stream<E> &lt;-&gt; Iterable<E> 중개 어댑터 메서드를 사용하면 괜찮다.</E></E></p></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// Stream에서 Iterable로  </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterableOf</span><span class="token punctuation">(</span><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> stream<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> stream<span class="token operator">::</span><span class="token function">iterator</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Iterable에서 Stream으로  </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">streamOf</span><span class="token punctuation">(</span><span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> iterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token class-name">StreamSupport</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>iterable<span class="token punctuation">.</span><span class="token function">spliterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><ul><li>Collection 인터페이스는 Iterable의 하위 타입이고 stream 메서드도 제공함
<ul><li>그러므로, 원소 시퀀스를 반환하는 공개 API의 반환 타입에는 Collection이나 그 하위 타입을 쓰는 것이 일반적으로 최선</li></ul></li></ul> <h3 id="_48-스트림-병렬화는-주의해서-적용하라"><a href="#_48-스트림-병렬화는-주의해서-적용하라" class="header-anchor">#</a> 48. 스트림 병렬화는 주의해서 적용하라</h3> <ul><li>스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스 / 배열 / int, long 범위일 때 병렬화의 효과가 제일 좋다.
<ul><li>데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어 일을 다수의 thread에 분배하기 좋음</li> <li>또한 참조 지역성(locality of reference)이 뛰어남.
<ul><li>이웃한 원소의 참조들이 메모리에 연속해서 저장되어 있음</li></ul></li></ul></li> <li>스트림을 잘못 병렬화하면 응답 불가가 되거나, 오히려 성능이 나빠지거나, 예상 못한 동작이 발생할 수 있음
<ul><li>테스트 필수!</li> <li>계산도 아주 정확하고 성능이 정말 좋아져서 병렬화를 사용할 만한 가치가 있을 떄만 사용한다.</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/effective-java-study/assets/js/app.34abd0d4.js" defer></script><script src="/effective-java-study/assets/js/2.28ccdcca.js" defer></script><script src="/effective-java-study/assets/js/11.d58abc29.js" defer></script>
  </body>
</html>
